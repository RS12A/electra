input {
  # HTTP input for Flutter log shipping
  http {
    port => 5000
    codec => json
    tags => ["flutter", "mobile"]
  }
  
  # File input for Django logs
  file {
    path => "/var/log/electra/django.log"
    start_position => "beginning"
    codec => json
    tags => ["django", "backend"]
    type => "django-app"
  }
  
  # File input for audit logs
  file {
    path => "/var/log/electra/audit-*.jsonl"
    start_position => "beginning"
    codec => json
    tags => ["audit", "security"]
    type => "audit-log"
  }
  
  # Syslog input
  syslog {
    port => 514
    tags => ["syslog", "system"]
  }
  
  # Docker logs via filebeat pattern
  beats {
    port => 5044
    tags => ["beats", "containers"]
  }
}

filter {
  # Common timestamp parsing
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601" ]
    }
  }
  
  # Django log processing
  if "django" in [tags] {
    # Parse request data if present
    if [data][request_id] {
      mutate {
        add_field => { "request_id" => "%{[data][request_id]}" }
      }
    }
    
    if [data][user] {
      mutate {
        add_field => { 
          "user_id" => "%{[data][user][id]}"
          "username" => "%{[data][user][username]}"
        }
      }
    }
    
    if [data][method] and [data][path] {
      mutate {
        add_field => { 
          "http_method" => "%{[data][method]}"
          "http_path" => "%{[data][path]}"
          "http_status" => "%{[data][status_code]}"
        }
      }
    }
    
    if [data][response_time_ms] {
      mutate {
        convert => { "response_time_ms" => "float" }
      }
    }
    
    # Anonymize IP addresses
    if [data][ip_address] {
      mutate {
        gsub => [ "[data][ip_address]", "(\d+\.\d+\.\d+)\.\d+", "\1.xxx" ]
      }
    }
  }
  
  # Flutter log processing
  if "flutter" in [tags] {
    # Extract client information
    if [metadata] {
      mutate {
        add_field => {
          "client_type" => "flutter"
          "app_version" => "%{[metadata][app_version]}"
          "platform" => "%{[metadata][platform]}"
        }
      }
    }
    
    # Process individual log entries
    if [logs] {
      split {
        field => "logs"
      }
      
      # Extract fields from individual log entries
      mutate {
        add_field => {
          "level" => "%{[logs][level]}"
          "logger" => "%{[logs][logger]}"
          "message" => "%{[logs][message]}"
          "device_id" => "%{[logs][device_id]}"
        }
      }
      
      # Parse timestamp from log entry
      if [logs][@timestamp] {
        date {
          match => [ "[logs][@timestamp]", "ISO8601" ]
        }
      }
    }
    
    # Redact sensitive information from Flutter logs
    mutate {
      gsub => [
        "message", "(?i)(password|token|key|secret|matric)[\"\\s]*[:=][\"\\s]*[^\"\\s,}]+", "\\1=[REDACTED]"
      ]
    }
  }
  
  # Audit log processing
  if "audit" in [tags] {
    # Mark audit logs for special handling
    mutate {
      add_field => { 
        "log_type" => "audit"
        "security_category" => "%{[data][security_level]}"
        "tamper_proof" => "true"
      }
    }
    
    # Verify signature if present
    if [signature] {
      mutate {
        add_field => { "signature_verified" => "pending" }
      }
    }
    
    # Extract election information
    if [data][election_id] {
      mutate {
        add_field => { "election_id" => "%{[data][election_id]}" }
      }
    }
    
    # Anonymize user information in audit logs
    if [data][voter_id] {
      mutate {
        add_field => { "voter_id_hash" => "%{[data][voter_id]}" }
      }
    }
  }
  
  # GeoIP enrichment for IP addresses (optional)
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
    
    # Remove precise location for privacy
    mutate {
      remove_field => [ "[geoip][latitude]", "[geoip][longitude]" ]
    }
  }
  
  # Add common fields
  mutate {
    add_field => {
      "environment" => "${ENVIRONMENT:development}"
      "service" => "electra"
      "processed_at" => "%{@timestamp}"
    }
  }
  
  # Clean up temporary fields
  mutate {
    remove_field => [ "host", "agent", "ecs" ]
  }
  
  # Performance monitoring
  if [data][duration_ms] {
    mutate {
      convert => { "[data][duration_ms]" => "integer" }
    }
    
    # Add performance tags
    if [data][duration_ms] > 5000 {
      mutate {
        add_tag => [ "slow_operation" ]
      }
    }
  }
  
  # Error detection and tagging
  if [level] {
    if [level] == "ERROR" or [level] == "CRITICAL" {
      mutate {
        add_tag => [ "error" ]
      }
    }
    
    if [level] == "WARNING" {
      mutate {
        add_tag => [ "warning" ]
      }
    }
  }
  
  # Security event detection
  if [event_type] {
    if [event_type] =~ /^security_/ {
      mutate {
        add_tag => [ "security_event" ]
      }
    }
    
    if [event_type] == "vote_cast" {
      mutate {
        add_tag => [ "election_event", "vote_cast" ]
      }
    }
  }
}

output {
  # Main Elasticsearch output
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "electra-logs-%{+YYYY.MM.dd}"
    template_name => "electra-logs"
    template => "/usr/share/logstash/templates/electra-template.json"
    template_overwrite => true
  }
  
  # Separate index for audit logs
  if "audit" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "electra-audit-%{+YYYY.MM.dd}"
      template_name => "electra-audit"
      template => "/usr/share/logstash/templates/electra-audit-template.json"
      template_overwrite => true
    }
  }
  
  # Security events to separate index
  if "security_event" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "electra-security-%{+YYYY.MM.dd}"
    }
  }
  
  # Performance logs to separate index
  if "slow_operation" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "electra-performance-%{+YYYY.MM.dd}"
    }
  }
  
  # Error logs to separate index for quick access
  if "error" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "electra-errors-%{+YYYY.MM.dd}"
    }
  }
  
  # Debug output (optional, comment out in production)
  if "${LOG_LEVEL:INFO}" == "DEBUG" {
    stdout { 
      codec => rubydebug 
    }
  }
}